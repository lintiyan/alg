package main

import (
	"fmt"
	"math"
)

/*

	给你一个大小为 m x n 的二进制矩阵 grid 。

	岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

	岛屿的面积是岛上值为 1 的单元格的数目。

	计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。

	示例 1：

	输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
	输出：6
	解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
	示例 2：

	输入：grid = [[0,0,0,0,0,0,0,0]]
	输出：0

*/

func maxAreaOfIsland(grid [][]int) int {

	var row = len(grid)
	var col = len(grid[0])
	var matrix [][]int

	for i := 0; i < row; i++ {
		var item = make([]int, col)
		matrix = append(matrix, item)
	}

	var gridIndex = 1
	var colorIndex int
	var maGridArea = make(map[int]int)
	var maGridColor = make(map[int]int)
	var maSameColor = make(map[int][]int)

	for i := 0; i < row; i++ {
		for j := 0; j < col; j++ {

			if grid[i][j] > 0 {

				leftExistGrid := isLeftExistGrid(i, j, grid)
				upExistGrid := isUpExistGrid(i, j, grid)

				if leftExistGrid && !upExistGrid {
					matrix[i][j] = matrix[i][j-1]
					maGridArea[matrix[i][j-1]] += 1

				} else if !leftExistGrid && upExistGrid {

					matrix[i][j] = matrix[i-1][j]
					maGridArea[matrix[i-1][j]] += 1

				} else if leftExistGrid && upExistGrid {

					matrix[i][j] = matrix[i][j-1]
					maGridArea[matrix[i][j-1]] += 1

					maSameColor[colorIndex] = append(maSameColor[colorIndex], maSameColor[maGridColor[matrix[i][j-1]]]...)
					maSameColor[colorIndex] = append(maSameColor[colorIndex], maSameColor[maGridColor[matrix[i-1][j]]]...)

					maGridColor[matrix[i][j-1]] = colorIndex
					maGridColor[matrix[i-1][j]] = colorIndex

					colorIndex++

				} else {

					maGridArea[gridIndex] += 1
					maGridColor[gridIndex] = colorIndex
					maSameColor[colorIndex] = []int{gridIndex}
					matrix[i][j] = gridIndex

					gridIndex++
					colorIndex++
				}
			}
		}
	}

	var max int
	for _, list := range maSameColor {
		var ma = make(map[int]bool)
		var colorSum int
		for _, item := range list {
			if ma[item] {
				continue
			}
			colorSum += maGridArea[item]
			ma[item] = true
		}
		if colorSum > max {
			max = colorSum
		}
	}

	return max
}

func maxAreaOfIsland2(grid [][]int) int {

	var max int
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			max = int(math.Max(float64(max), float64(dfs(grid, i, j))))
		}
	}
	return max
}

func dfs(grid [][]int, i int, j int) int {

	if i < 0 || j < 0 || i >= len(grid) || j >= len(grid[0]) || grid[i][j] == 0 {
		return 0
	}

	grid[i][j] = 0
	ans := 1

	targetI := []int{-1, 0, 1, 0}
	targetJ := []int{0, 1, 0, -1}

	for index := 0; index < 4; index++ {
		ans += dfs(grid, i+targetI[index], j+targetJ[index])
	}
	return ans
}

func main() {
	//
	//var grid = [][]int{
	//	{0,0,1,0,0,0,0,1,0,0,0,0,0},
	//	{0,0,0,0,0,0,0,1,1,1,0,0,0},
	//	{0,1,1,0,1,0,0,0,0,0,0,0,0},
	//	{0,1,0,0,1,1,0,0,1,0,1,0,0},
	//	{0,1,0,0,1,1,0,0,1,1,1,0,0},
	//	{0,0,0,0,0,0,0,0,0,0,1,0,0},
	//	{0,0,0,0,0,0,0,1,1,1,0,0,0},
	//	{0,0,0,0,0,0,0,1,1,0,0,0,0},
	//}

	//var grid = [][]int{{0,0,0,0,0,0,0,0}}
	//var grid = [][]int{{0,1}}
	//var grid = [][]int{
	//	{0,1,1},
	//	{1,1,1},
	//}

	//var grid = [][]int{
	//	{0, 1},
	//	{1, 1},
	//	{1, 1},
	//}

	//var grid = [][]int{
	//	{1,1,0,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,0},
	//	{0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,0,1},
	//	{1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1},
	//	{0,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1},
	//	{1,1,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,0,1},
	//	{0,1,0,1,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1},
	//	{1,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,1,1,1,0,0,0,0,0},
	//	{0,1,1,1,1,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1},
	//	{1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,0,0},
	//	{0,1,1,1,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,0,1,1,1},
	//	{0,1,1,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0},
	//	{1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1},
	//	{1,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1},
	//	{1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,0,1,1},
	//	{0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,0},
	//	{0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,0,1,0,1,1,1,1,1,1,1},
	//	{0,0,1,1,1,1,0,1,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,1},
	//	{1,0,0,1,0,1,0,0,1,1,1,1,0,0,0,1,0,1,0,1,1,1,0,1,1},
	//	{0,0,0,0,1,0,0,1,0,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0},
	//	{1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1},
	//	{1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1},
	//	{1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,1,0,1,0,1,0,0,0,0,0},
	//	{1,0,0,0,0,1,1,0,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0},
	//	{0,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1},
	//	{1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,1,0,1,0,0,0,1,0,0,0},
	//	{0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0},
	//	{0,1,1,1,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,1},
	//	{1,0,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0},
	//	{1,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,0,0,0},
	//	{0,0,0,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,0},
	//	{1,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,0,0,1,0,1},
	//	{0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,0,0,0,1,1,0,0},
	//	{0,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,0,1,1,1,1},
	//	{0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,0},
	//	{1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1},
	//	{1,0,1,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,0,1,1,0,0,1},
	//	{0,1,0,0,0,1,0,1,1,1,1,1,0,0,0,1,0,0,0,0,1,0,1,0,1},
	//	{0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,1},
	//	{1,1,0,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,0,0,0,0,1,0},
	//	{1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,1,0,0,0,0,0},
	//	{1,0,0,0,1,0,0,1,0,0,0,0,1,1,1,1,1,1,0,0,1,0,0,0,1},
	//	{0,1,0,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,1,0},
	//	{1,1,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1},
	//	{1,0,0,1,0,1,0,1,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,0,0},
	//	{1,1,1,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0},
	//	{1,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1},
	//	{0,1,1,0,1,0,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,0,1},
	//	{0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,1},
	//	{0,0,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0},
	//	{1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,0,1,0},
	//}

	//var grid = [][]int{
	//	{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
	//	{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//	{0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
	//	{0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0},
	//	{0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0},
	//	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
	//	{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0},
	//	{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
	//}

	var grid = [][]int{
		{1, 1, 0, 1, 0, 0, 1, 1},
		{0, 1, 0, 1, 1, 1, 1, 0},
		{1, 1, 1, 1, 0, 0, 0, 1},
	}
	fmt.Println("1=",maxAreaOfIsland(grid))
	fmt.Println("2=",maxAreaOfIsland2(grid))
}

func isLeftExistGrid(i, j int, grid [][]int) bool {
	if j == 0 {
		return false
	}

	if grid[i][j-1] > 0 {
		return true
	}

	return false
}

func isUpExistGrid(i, j int, grid [][]int) bool {
	if i == 0 {
		return false
	}

	if grid[i-1][j] > 0 {
		return true
	}

	return false
}
